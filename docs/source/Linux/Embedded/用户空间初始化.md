# 用户空间初始化

我们现在来研究内核初始化之后的系统初始化。

## 1. 根文件系统

内核需要挂载一个根文件系统。

根文件系统是内核挂载的第一个文件系统，挂载的位置是文件系统层次的顶端，表示为 `/`。

Linux 系统对根文件系统有一些特殊的需求。

### 1.1 FHS: 文件系统层次结构标准

FHS 标准用来规定 UNIX 文件系统的组织结构和布局，增强了不同 Linux 发行版和应用程序之间的兼容性。

这样我们可以大概知道哪些系统成员(文件和目录)在文件系统重的位置。

### 1.2 文件系统布局

在存储空间有限的系统，有这样的方法：
现在一个可引导设备上创建一个很小的根文件系统，之后从另一个设备挂载一个较大的文件系统。

```text
root@localhost:~# ls /
afs  bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
```

嵌入式系统往往除了根用户之外没有其他用户。

### 1.3 最小化的文件系统

`busybox` 是一个独立的二进制执行工具，包含了很多 Linux 常用命令行实用程序。

```text
/bin/busybox
/dev/console
/etc/init.d/rcS
/lib/ld.so
/lib/libc.so
```

一个功能完备的最小化根文件系统

### 1.4 嵌入式根文件系统带来的挑战

删减一个根文件系统的内容，是它的大小能够适应给定的存储空间是一项艰巨的任务。

有的程序所需要的文件分散在文件系统中的多个不同位置。

Linux 发行版的产商，花费大量的工程资源来完成这样的工作：
将大量的程序、程序库、工具、实用软件和应用程序集中打包在一起，制作成一个发行版。

构建根文件系统必然涉及若干发行版的制作工作，只是规模小一些。

### 1.5 试错法

直到最近，填充根文件系统内容的唯一方法就是试错法。

### 1.6 自动化文件系统构建工具

开源的自动化文件系统构建工具：

`bitbake`

`buildroot`

## 2. 内核的最后一些引导步骤

现在我们来关注 `init/main.c` 中的 `start_kernel()`，调用了一个内核线程 `kernel_init()`

```c++
static int __ref kernel_init(void *unused)
{
    /*  这个函数的最后几行 */
    if (!try_to_run_init_process("/sbin/init") ||
        !try_to_run_init_process("/etc/init") ||
        !try_to_run_init_process("/bin/init") ||
        !try_to_run_init_process("/bin/sh"))
        return 0;

    panic("No working init found.  Try passing init= option to kernel. "
          "See Linux Documentation/admin-guide/init.rst for guidance.");
}
```

内核如果不能执行这些进程中的一个，那么就会调用 `panic` ，进而崩溃。

### 2.1 第一个用户空间程序

内核的执行次序：

(1). 挂载根文件系统

(2). 执行第一个用户空间程序，在这里指的是 `/sbin/init`

### 2.2 解决依赖关系

将一个可执行文件放入文件系统时，必须同时满足它的依赖关系。

应用程序一般有2种依赖关系：

- 动态链接的程序对程序库的依赖，这些程序包含未解决的引用，这需要由程序库提供；
- 应用程序可能需要外部配置文件或数据文件。

我们可以使用 `ldd` 工具来确定第一种关系；
第二种关系则需要我们了解这个子系统如何工作。

### 2.3 定制的初始进程

系统用户可以在启动时控制执行哪个进程，这通过一个内核命令行参数实现。

```text
console=ttyS0,115200 ip=bootp root=/dev/nfs init=/sbin/my_init
```

这样的话，内核引导完成后，`my_init` 将成为第一个获得控制权的进程。

> 一般来说，永远不需要你自己提供定制的初始化进程。
> 标准的 `init` 进程的功能已经非常强大和灵活了。

## 3. init 进程

`init` 进程是内核完成引导过程之后创建的第一个用户空间进程。

`init` 进程是 Linux 系统中所有用户进程的最终父进程。

init 提供了一组默认的环境参数，比如初始系统 PATH，而所有其他进程都会进程这组参数。

init 的一个主要功能是根据一个特定的配置文件生成其他进程。
init 有运行级别的概念。每个运行级别是由进入这个级别时所运行的服务和生成的程序决定的。

每个运行级别一般都有一组相关的启动和关闭脚本，它们定义了系统处于这个运行级别时的动作和行为。

```text
init 0 # 系统关机
init 6 # 系统重启
```

与运行级别相关的脚本文件一般位于目录 `/etc/rc.d/init.d`。
现在只有一个 README 文件了，功能已经由 `systemctl` 去执行。

## 4. 初始 RAM 磁盘 (init ramdisk)

Linux 内核中包含了2种挂载早期根文件系统的机制，用于执行某些和启动相关的系统初始化及配置。

- 模拟磁盘镜像的思路 **initrd**
- 文件系统镜像的思路 **initramfs**

`bootm 0x10000000 0x10800040`

U-Boot 的 `bootm` 命令的含义是从内存引导(boot from memory)。
`bootm` 命令有两个参数，一个是 Linux 内核镜像的地址，另一个参数是可选的，一般是 `ramdisk` 镜像的地址。

**TODO**:
initrd 的工作方式还要仔细研究吗？

## 5. 使用 initramfs

`initramfs` 的工作：
在挂载真正的根文件系统之前加载一些必需的驱动程序。

initramfs 已经集成到 Linux 内核源码中了，在构建内核的时候会自动生成。

> 如何自定义 initramfs 呢？

## 6. 关机

对于嵌入式系统，不恰当的关机会影响启动时间，甚至会损坏某些文件系统。

不同的平台和系统规模需要不同的关机策略。

有几个 Linux 系统下的工具可以帮助你实现关机操作:
`shutdown`, `halt`, `reboot`

> 关机系统方案需要结合具体的系统架构设计实现。
